'use client';

import { useState, useRef, useMemo, useEffect } from 'react';
import { quizService, questionService } from '../../services/apiService';

export default function TestCreation({ testConfig, onBack, onSubmit, user }) {
  const [loading, setLoading] = useState(true);
  
  // testConfig가 null일 때 기본값 제공
  const safeTestConfig = testConfig || {
    title: '새 테스트',
    numofquestion: 2,
    time_limit_sec: 3600,
    open_at: '2025-08-01T00:00', // 2025.8.1 기본값
    close_at: '2025-08-31T23:59', // 2025.8.31 기본값
    target_score: 70,
    questions: [] // questions 배열 추가
  };
  
  console.log('TestCreation testConfig:', testConfig);
  console.log('TestCreation safeTestConfig:', safeTestConfig);
  console.log('TestCreation safeTestConfig.id:', safeTestConfig.id);
  const normalizeQuestion = (q, id) => ({
    id: id || q?.id || Date.now() + Math.random(), // 고유 ID 보장
    type: q?.type || 'dictation', // essay -> dictation으로 변경
    question: q?.question || '',
    correctAnswer: q?.correctAnswer ?? '',
    explanation: q?.explanation || '',
    points: q?.points ?? 1,
    vocabId: q?.vocabId || null,
    vocab: q?.vocab || null, // 백엔드에서 제공하는 vocab 정보
    options: q?.options || [] // 4지선다 문제의 선지들
  });

  const initialQuestions = useMemo(() => {
    if (!safeTestConfig) return []; // safeTestConfig가 없으면 빈 배열 반환
    
    const existing = Array.isArray(safeTestConfig.questions) ? safeTestConfig.questions : [];
    const count = safeTestConfig.numofquestion || 2; // 기본값 추가
    const arr = Array.from({ length: count }, (_, index) => {
      const existingQ = existing[index];
      return normalizeQuestion(existingQ, index + 1);
    });
    return arr;
  }, [safeTestConfig]);

  const [questions, setQuestions] = useState([]); // 빈 배열로 초기화
  const [savedQuestions, setSavedQuestions] = useState([]); // 저장된 문제들
  const [savingQuestion, setSavingQuestion] = useState(false); // 문제 저장 중 상태

  // safeTestConfig가 변경될 때 questions 업데이트
  useEffect(() => {
    if (!safeTestConfig) return; // safeTestConfig가 없으면 리턴
    
    // 자동 생성 모드인 경우
    if (safeTestConfig.isAutoGenerated && safeTestConfig.autoGeneratedQuestions) {
      console.log('자동 생성 모드: AI가 생성한 문제들 로드');
      console.log('자동 생성된 문제들:', safeTestConfig.autoGeneratedQuestions);
      
      // AI가 생성한 문제들을 로드
      const autoGeneratedQuestions = safeTestConfig.autoGeneratedQuestions.map((q, index) => {
        // vocabId로부터 vocab 정보 찾기
        let vocabInfo = null;
        if (q.vocabId && safeTestConfig.autoGeneratedVocabs) {
          vocabInfo = safeTestConfig.autoGeneratedVocabs.find(v => v.id === q.vocabId);
          console.log(`문제 ${q.id}의 vocabId ${q.vocabId}에 대한 vocab 정보:`, vocabInfo);
        }
        
        const questionData = {
          id: q.id || index + 1,
          type: q.type || 'dictation',
          vocabId: q.vocabId,
          question: q.question || q.stem || '',
          correctAnswer: q.correctAnswer || '',
          explanation: q.explanation || '',
          points: q.points || 1,
          vocab: vocabInfo || q.vocab || null, // vocab 정보 연결
          options: q.options || [] // multiple choice 옵션들
        };
        
        console.log(`자동 생성 문제 ${questionData.id} 로드 완료:`, questionData);
        return questionData;
      });
      
      setQuestions(autoGeneratedQuestions);
      setSavedQuestions(autoGeneratedQuestions); // 자동 생성된 문제들을 저장된 것으로 표시
      setLoading(false);
    }
    // 기존 문제들이 있는 경우 (편집 모드)
    else if (safeTestConfig.questions && Array.isArray(safeTestConfig.questions) && safeTestConfig.questions.length > 0) {
      console.log('기존 문제들 로드:', safeTestConfig.questions);
      console.log('selectedVocabs 정보:', safeTestConfig.selectedVocabs);
      
      // 기존 문제들을 로드하고 vocab 정보를 올바르게 연결
      const existingQuestions = safeTestConfig.questions.map((q, index) => {
        // vocabId로부터 vocab 정보 찾기
        let vocabInfo = null;
        if (q.vocabId && safeTestConfig.selectedVocabs) {
          vocabInfo = safeTestConfig.selectedVocabs.find(v => v.id === q.vocabId);
          console.log(`문제 ${q.id}의 vocabId ${q.vocabId}에 대한 vocab 정보:`, vocabInfo);
        }
        
        const questionData = {
          id: q.id || index + 1,
          type: q.type || 'dictation',
          vocabId: q.vocabId,
          question: q.question || q.stem || '',
          correctAnswer: q.correctAnswer || '',
          explanation: q.explanation || '',
          points: q.points || 1,
          vocab: vocabInfo || q.vocab || null, // vocab 정보 연결
          options: q.options || [] // multiple choice 옵션들
        };
        
        console.log(`문제 ${questionData.id} 로드 완료:`, questionData);
        return questionData;
      });
      
      setQuestions(existingQuestions);
      setSavedQuestions(existingQuestions); // 기존 문제들을 저장된 것으로 표시
      setLoading(false);
    } else {
      // 새로 생성하는 경우
      console.log('새 문제들 생성:', initialQuestions);
      setQuestions(initialQuestions);
      setLoading(false);
    }
  }, [safeTestConfig, initialQuestions]);

  const [currentQuestion, setCurrentQuestion] = useState(0);
  
  // questions가 변경될 때 currentQuestion이 유효한 범위인지 확인
  useEffect(() => {
    if (questions.length > 0 && currentQuestion >= questions.length) {
      setCurrentQuestion(0);
    }
  }, [questions.length, currentQuestion]);

  // 모든 문제가 완성되었는지 확인
  const areAllQuestionsComplete = () => {
    if (questions.length === 0) return false;
    
    return questions.every(question => 
      question && 
      question.question && 
      question.question.trim() && 
      question.vocabId &&
      question.correctAnswer !== undefined && 
      question.correctAnswer !== null && 
      question.correctAnswer !== ''
    );
  };

  // 나가기 시도 시 경고
  const handleExitAttempt = async () => {
    const completedQuestions = questions.filter(q => 
      q && q.question && q.question.trim() && q.vocabId && q.correctAnswer !== undefined && q.correctAnswer !== null && q.correctAnswer !== ''
    );
    
    if (completedQuestions.length < questions.length) {
      const incompleteCount = questions.length - completedQuestions.length;
      const confirmExit = confirm(
        `아직 ${incompleteCount}개의 질문이 모두 작성되지 않았어요!\n\n그래도 나가시겠어요? 그러면 저장되지 않습니다!`
      );
      
      if (confirmExit) {
        // 퀴즈 삭제
        if (safeTestConfig.id) {
          try {
            console.log('미완성 퀴즈 삭제 시작:', safeTestConfig.id);
            await quizService.deleteQuiz(safeTestConfig.id);
            console.log('미완성 퀴즈 삭제 완료');
          } catch (error) {
            console.error('퀴즈 삭제 오류:', error);
          }
        }
        onBack();
      }
    } else {
      onBack();
    }
  };
  const questionRefs = useRef([]);

  const updateQuestion = (index, field, value) => {
    setQuestions(prev => {
      const updated = prev.map((q, i) => {
        if (i === index) {
          const newQuestion = { ...q, [field]: value };
          
          // vocabId가 변경되면 vocab 정보도 업데이트
          if (field === 'vocabId') {
            const vocab = safeTestConfig.selectedVocabs && safeTestConfig.selectedVocabs.find(v => v.id === value);
            if (vocab) {
              newQuestion.vocab = vocab;
            }
          }
          
          // 문제 유형이 변경되면 자동으로 문제 내용 채우기
          if (field === 'type' && value !== q.type) {
            // vocabId로부터 vocab 정보 찾기
            const vocab = safeTestConfig.selectedVocabs && safeTestConfig.selectedVocabs.find(v => v.id === newQuestion.vocabId);
            if (vocab) {
              switch (value) {
                case 'dictation':
                  newQuestion.question = `이 단어를 듣고 스펠링을 쓰시오: "${vocab.word}"`;
                  newQuestion.correctAnswer = vocab.word;
                  newQuestion.explanation = `${vocab.word}는 ${vocab.definition}을 의미합니다.`;
                  break;
                  
                case 'ox':
                  // 단어:뜻 매치 형태로 OX 문제 생성
                  // 50% 확률로 정답 또는 오답 매치 생성
                  const isCorrect = Math.random() > 0.5;
                  
                  if (isCorrect) {
                    // 정답 매치: 올바른 단어와 뜻
                    newQuestion.question = `${vocab.word} : ${vocab.definition}`;
                    newQuestion.correctAnswer = 1; // O
                  } else {
                    // 오답 매치: 다른 단어의 뜻과 매치
                    const otherVocabs = safeTestConfig.selectedVocabs.filter(v => v.id !== vocab.id);
                    if (otherVocabs.length > 0) {
                      const randomVocab = otherVocabs[Math.floor(Math.random() * otherVocabs.length)];
                      newQuestion.question = `${vocab.word} : ${randomVocab.definition}`;
                      newQuestion.correctAnswer = 0; // X
                    } else {
                      // 다른 단어가 없으면 임의의 틀린 뜻 생성
                      const wrongDefinitions = ['잘못된 뜻', '틀린 의미', '다른 뜻'];
                      const randomWrongDef = wrongDefinitions[Math.floor(Math.random() * wrongDefinitions.length)];
                      newQuestion.question = `${vocab.word} : ${randomWrongDef}`;
                      newQuestion.correctAnswer = 0; // X
                    }
                  }
                  newQuestion.explanation = `${vocab.word}는 ${vocab.definition}을 의미합니다.`;
                  break;
                  
                case 'multiple':
                  // 4지선다 문제 생성 (한국어 뜻을 문제로, 영어 단어를 선지로)
                  const otherVocabs = questions.filter(q => q.vocab && q.vocab.id !== vocab.id);
                  const shuffledVocabs = [...otherVocabs].sort(() => Math.random() - 0.5);
                  const options = [
                    vocab.word, // 정답 (영어 단어)
                    ...shuffledVocabs.slice(0, 3).map(q => q.vocab.word) // 오답 3개 (영어 단어)
                  ].sort(() => Math.random() - 0.5); // 옵션 순서 섞기
                  
                  const correctIndex = options.indexOf(vocab.word);
                  
                  newQuestion.question = `${vocab.definition} - 이 뜻을 가진 단어는?`;
                  newQuestion.correctAnswer = correctIndex;
                  newQuestion.options = options;
                  newQuestion.explanation = `${vocab.definition}는 ${vocab.word}을 의미합니다.`;
                  break;
              }
            }
          }
          
          return newQuestion;
        }
        return q;
      });
      return updated;
    });
  };

  // 개별 문제 저장 함수
  const saveCurrentQuestion = async () => {
    const currentQ = questions[currentQuestion];
    if (!currentQ || !currentQ.question || !currentQ.question.trim()) {
      alert('문제 내용을 입력해주세요!');
      return;
    }
    
    if (!currentQ.vocabId) {
      alert('문제와 관련된 단어장을 선택해주세요!');
      return;
    }

    setSavingQuestion(true);
    try {
      // 현재 문제를 저장된 문제 목록에 추가/업데이트
      setSavedQuestions(prev => {
        const updated = [...prev];
        updated[currentQuestion] = { ...currentQ, saved: true };
        return updated;
      });

      // 다음 문제로 이동
      if (currentQuestion < questions.length - 1) {
        setCurrentQuestion(currentQuestion + 1);
      }
      
      console.log(`문제 ${currentQuestion + 1} 저장 완료:`, currentQ);
      alert('✅ 문제가 저장되었습니다!');
    } catch (error) {
      console.error('문제 저장 오류:', error);
      alert('문제 저장에 실패했습니다. 다시 시도해주세요.');
    } finally {
      setSavingQuestion(false);
    }
  };

  // 모든 문제가 저장되었는지 확인
  const isAllQuestionsSaved = () => {
    console.log('=== 저장 상태 확인 ===');
    console.log('questions:', questions);
    console.log('savedQuestions:', savedQuestions);
    console.log('questions.length:', questions.length);
    console.log('savedQuestions.length:', savedQuestions.length);
    
    // questions 배열의 길이만큼 확인
    for (let i = 0; i < questions.length; i++) {
      const question = questions[i];
      const savedQuestion = savedQuestions[i];
      
      // 문제 내용 확인 (question 필드 또는 stem 필드 사용)
      const questionContent = question?.question || question?.stem || '';
      const savedQuestionContent = savedQuestion?.question || savedQuestion?.stem || '';
      
      console.log(`문제 ${i + 1}:`, {
        hasQuestion: !!question,
        hasContent: questionContent && questionContent.trim(),
        isSaved: savedQuestion && savedQuestion.saved,
        questionContent: questionContent,
        savedQuestionContent: savedQuestionContent,
        questionType: question?.type,
        vocabId: question?.vocabId
      });
      
      // 문제가 없거나 내용이 없으면 false
      if (!question || !questionContent || !questionContent.trim()) {
        console.log(`문제 ${i + 1} 실패: 내용 없음`);
        return false;
      }
      
      // vocabId가 없으면 false
      if (!question.vocabId) {
        console.log(`문제 ${i + 1} 실패: vocabId 없음`);
        return false;
      }
      
      // 저장되지 않았으면 false
      if (!savedQuestion || !savedQuestion.saved) {
        console.log(`문제 ${i + 1} 실패: 저장되지 않음`);
        return false;
      }
    }
    
    console.log('모든 문제 저장됨!');
    return questions.length > 0; // 최소 1개 이상의 문제가 있어야 함
  };

  const updateOption = (questionIndex, optionIndex, value) => {
    setQuestions(prev => prev.map((q, i) => 
      i === questionIndex 
        ? { ...q, options: q.options.map((opt, oi) => oi === optionIndex ? value : opt) }
        : q
    ));
  };

  const scrollToQuestion = (index) => {
    questionRefs.current[index]?.scrollIntoView({ 
      behavior: 'smooth',
      block: 'start'
    });
    setCurrentQuestion(index);
  };

  const handleSubmit = async () => {
    // 모든 문제가 저장되었는지 확인
    if (!isAllQuestionsSaved()) {
      alert('모든 문제를 저장해주세요! 저장되지 않은 문제가 있습니다.');
      return;
    }
    
    // 저장된 문제들 사용
    const finalQuestions = savedQuestions.filter(q => q && q.saved);
    
    if (finalQuestions.length === 0) {
      alert('저장된 문제가 없습니다. 문제를 작성하고 저장해주세요.');
      return;
    }
    
    // 유효성 검사
    const invalidQuestions = finalQuestions.filter(q => {
      const questionContent = q?.question || q?.stem || '';
      return !q || !questionContent || !questionContent.trim() || 
        (q.type === 'multiple' && q.options && q.options.some(opt => !opt.trim()));
    });

    if (invalidQuestions.length > 0) {
      alert(`${invalidQuestions.length}개의 문제가 완성되지 않았습니다. 모든 문제를 완성해주세요! 📝`);
      return;
    }

    try {
      // 퀴즈 생성
      const quizData = {
        title: safeTestConfig.title,
        numOfQuestions: safeTestConfig.numofquestion,
        timeLimitSec: safeTestConfig.time_limit_sec,
        openAt: safeTestConfig.open_at,
        closeAt: safeTestConfig.close_at,
        targetScore: safeTestConfig.target_score,
        createdBy: user.id
      };

      console.log('퀴즈 생성 시작:', quizData);
      const createdQuiz = await quizService.createQuiz(quizData);
      console.log('퀴즈 생성 완료:', createdQuiz);

      // 문제들을 생성된 퀴즈에 연결
      const questionsWithQuizId = finalQuestions.map(q => ({
        ...q,
        quizId: createdQuiz.id
      }));

      // 각 문제를 백엔드에 저장
      for (const question of questionsWithQuizId) {
        const questionData = {
          quizId: question.quizId,
          type: question.type === 'dictation' ? 'DICTATION' : 
                question.type === 'ox' ? 'OX' : 
                question.type === 'multiple' ? 'MULTIPLE' : 'DICTATION',
          stem: question.question || question.stem || '',
          correctAnswer: question.type === 'multiple' ? 
            (question.correctAnswer ? parseInt(question.correctAnswer) : 0) : 
            question.correctAnswer,
          explanation: question.explanation || '',
          points: question.points || 1,
          vocabId: question.vocabId,
          options: question.type === 'multiple' ? (question.options && question.options.length > 0 ? question.options : []) : null
        };

        console.log(`문제 ${question.id} 생성 데이터:`, questionData);
        console.log(`원본 question 객체:`, question);
        console.log(`question.type:`, question.type);
        console.log(`question.options:`, question.options);
        console.log(`question.correctAnswer:`, question.correctAnswer);
        
        // 4지선다 문제인데 options가 없으면 경고
        if (question.type === 'multiple' && (!question.options || question.options.length === 0)) {
          console.warn(`⚠️ 4지선다 문제 ${question.id}에 options가 없습니다!`);
          console.warn(`문제 내용: ${question.question}`);
          console.warn(`정답: ${question.correctAnswer}`);
        }
        
        // 받아쓰기 문제인데 correctAnswer가 비어있으면 경고
        if (question.type === 'dictation' && (!question.correctAnswer || question.correctAnswer === '')) {
          console.warn(`⚠️ 받아쓰기 문제 ${question.id}에 correctAnswer가 없습니다!`);
          console.warn(`문제 내용: ${question.question}`);
        }
        
        console.log(`options 필드 확인:`, questionData.options);
        console.log(`correctAnswer 타입 확인:`, typeof questionData.correctAnswer, questionData.correctAnswer);
        const createdQuestion = await questionService.createQuestion(questionData);
        console.log(`문제 ${question.id} 생성 완료:`, createdQuestion);
      }

      const testData = {
        ...safeTestConfig,
        id: createdQuiz.id,
        questions: finalQuestions,
        createdAt: createdQuiz.createdAt || new Date().toISOString()
      };

      console.log('최종 퀴즈 데이터:', testData);
      
      // 확인 후 제출
      if (confirm('퀴즈를 완성하시겠습니까?')) {
        onSubmit(testData);
      }
    } catch (error) {
      console.error('퀴즈 생성 오류:', error);
      alert('퀴즈 생성 중 오류가 발생했습니다. 다시 시도해주세요.');
    }
  };

  // 선택된 vocab으로 문제 자동 생성 (더 이상 사용하지 않음)
  const generateQuestionsFromVocabs = () => {
    alert('이 기능은 더 이상 사용하지 않습니다. 단어는 이미 선택되었습니다.');
  };

  const renderQuestionEditor = (question, index) => {
    // question이 없으면 null 반환
    if (!question) return null;
    
    const questionId = question.id || index + 1; // 안전한 ID 사용
    
    return (
      <div
        key={questionId}
        ref={el => questionRefs.current[index] = el}
        className="bg-white/90 backdrop-blur-sm rounded-3xl p-8 shadow-xl border border-blue-200 mb-8"
      >
        {/* 문제 헤더 */}
        <div className="flex justify-between items-center mb-6">
          <div className="flex items-center space-x-3">
            <h3 className="text-2xl font-bold text-gray-800">
              📋 문제 {questionId}번
            </h3>
            {savedQuestions[index]?.saved && (
              <span className="px-3 py-1 bg-green-100 text-green-700 rounded-full text-sm font-medium">
                ✅ 저장됨
              </span>
            )}
            {!savedQuestions[index]?.saved && question.question && question.question.trim() && (
              <span className="px-3 py-1 bg-yellow-100 text-yellow-700 rounded-full text-sm font-medium">
                ⚠️ 저장 필요
              </span>
            )}
          </div>
          <div className="flex items-center space-x-4">
            {/* 문제 유형 선택 */}
            <select
              value={question.type}
              onChange={(e) => updateQuestion(index, 'type', e.target.value)}
              className="px-4 py-2 rounded-2xl border border-gray-300 focus:border-blue-500 outline-none text-gray-800 font-medium"
            >
              <option value="dictation" className="text-gray-800">받아쓰기</option>
              <option value="ox" className="text-gray-800">OX 문제</option>
              <option value="multiple" className="text-gray-800">4지선다</option>
            </select>
            
            {/* 배점 */}
            <div className="flex items-center space-x-2">
              <span className="text-sm text-gray-700">배점:</span>
              <input
                type="number"
                min="1"
                max="10"
                value={question.points}
                onChange={(e) => updateQuestion(index, 'points', parseInt(e.target.value))}
                className="w-16 px-2 py-1 rounded-lg border border-gray-300 focus:border-blue-500 outline-none text-center text-gray-800"
              />
              <span className="text-sm text-gray-700">점</span>
            </div>
          </div>
        </div>

        {/* 단어 선택 */}
        <div className="mb-6">
          <label className="block text-lg font-medium text-gray-700 mb-3">
            📚 단어 선택 <span className="text-red-500">*</span>
          </label>
          <select
            value={question.vocabId || ''}
            onChange={(e) => updateQuestion(index, 'vocabId', e.target.value ? parseInt(e.target.value) : null)}
            className="w-full px-4 py-3 rounded-2xl border border-gray-300 focus:border-blue-500 outline-none text-gray-800"
            required
          >
            <option value="">단어를 선택하세요 (필수)</option>
            {safeTestConfig.selectedVocabs && safeTestConfig.selectedVocabs.map((vocab) => (
              <option key={vocab.id} value={vocab.id}>
                {vocab.word} - {vocab.definition}
              </option>
            ))}
          </select>
          {!question.vocabId && (
            <p className="text-red-500 text-sm mt-2">⚠️ 문제와 관련된 단어를 선택해야 합니다.</p>
          )}
        </div>

        {/* 문제 내용 */}
        <div className="mb-6">
          <label className="block text-lg font-medium text-gray-700 mb-3">
            ❓ 문제
            {question.type === 'dictation' && (
              <button
                type="button"
                onClick={() => {
                  if (question.correctAnswer && 'speechSynthesis' in window) {
                    const utterance = new SpeechSynthesisUtterance(question.correctAnswer);
                    utterance.lang = 'en-US';
                    utterance.rate = 0.8;
                    speechSynthesis.speak(utterance);
                  }
                }}
                className="ml-4 px-3 py-1 bg-blue-500 hover:bg-blue-600 text-white rounded-lg text-sm transition-colors"
                title="정답 단어 듣기"
              >
                🔊 들어보기
              </button>
            )}
          </label>
          <textarea
            value={question.question}
            onChange={(e) => updateQuestion(index, 'question', e.target.value)}
            placeholder="문제를 입력하세요..."
            className="w-full px-4 py-3 rounded-2xl border border-gray-300 focus:border-blue-500 outline-none resize-none text-gray-800"
            rows={3}
          />
        </div>

        {question.type === 'ox' && (
          <div className="mb-6">
            <label className="block text-lg font-medium text-gray-700 mb-3">
              ⭕❌ 정답 선택
            </label>
            <div className="flex space-x-4">
              <button
                type="button"
                onClick={() => updateQuestion(index, 'correctAnswer', 1)}
                className={`px-8 py-4 rounded-2xl border-2 font-bold transition-all ${
                  question.correctAnswer === 1
                    ? 'bg-green-500 border-green-500 text-white'
                    : 'border-gray-300 hover:border-green-400'
                }`}
              >
                ⭕ 맞음 (O)
              </button>
              <button
                type="button"
                onClick={() => updateQuestion(index, 'correctAnswer', 0)}
                className={`px-8 py-4 rounded-2xl border-2 font-bold transition-all ${
                  question.correctAnswer === 0
                    ? 'bg-red-500 border-red-500 text-white'
                    : 'border-gray-300 hover:border-red-400'
                }`}
              >
                ❌ 틀림 (X)
              </button>
            </div>
          </div>
        )}

        {question.type === 'multiple' && (
          <div className="mb-6">
            <label className="block text-lg font-medium text-gray-700 mb-3">
              📝 4지선다 선지 입력
            </label>
            <div className="space-y-4">
              {['A', 'B', 'C', 'D'].map((option, optionIndex) => (
                <div key={optionIndex} className="flex items-center space-x-4">
                  <span className="w-8 h-8 bg-blue-500 text-white rounded-full flex items-center justify-center font-bold">
                    {option}
                  </span>
                  <input
                    type="text"
                    value={question.options?.[optionIndex] || ''}
                    onChange={(e) => {
                      const newOptions = [...(question.options || ['', '', '', ''])];
                      newOptions[optionIndex] = e.target.value;
                      updateQuestion(index, 'options', newOptions);
                    }}
                    placeholder={`선지 ${option} 입력...`}
                    className="flex-1 px-4 py-3 rounded-2xl border border-gray-300 focus:border-blue-500 outline-none text-gray-800"
                  />
                  <button
                    type="button"
                    onClick={() => {
                      updateQuestion(index, 'correctAnswer', optionIndex);
                    }}
                    className={`px-4 py-2 rounded-xl border-2 font-medium transition-all ${
                      question.correctAnswer === optionIndex
                        ? 'bg-green-500 border-green-500 text-white'
                        : 'border-gray-300 hover:border-green-400 text-gray-700'
                    }`}
                  >
                    정답
                  </button>
                </div>
              ))}
            </div>
            <div className="mt-4 p-4 bg-blue-50 rounded-2xl">
              <p className="text-sm text-blue-700">
                💡 <strong>정답:</strong> {question.correctAnswer !== null && question.correctAnswer !== undefined 
                  ? `${String.fromCharCode(65 + question.correctAnswer)}번 (${question.options?.[question.correctAnswer] || '미설정'})`
                  : '미설정'}
              </p>
            </div>
          </div>
        )}

        {question.type === 'dictation' && (
          <div className="mb-6">
            <label className="block text-lg font-medium text-gray-700 mb-3">
              ✍️ 정답 (영단어 입력)
            </label>
            <textarea
              value={question.correctAnswer || ''}
              onChange={(e) => updateQuestion(index, 'correctAnswer', e.target.value)}
              placeholder="학생이 입력해야 할 정답 영단어를 입력하세요..."
              className="w-full px-4 py-3 rounded-2xl border border-gray-300 focus:border-blue-500 outline-none resize-none text-gray-800"
              rows={3}
            />
          </div>
        )}

        {question.type === 'multiple' && (
          <div className="mb-6">
            <label className="block text-lg font-medium text-gray-700 mb-3">
              📝 보기 옵션
            </label>
            <div className="space-y-3">
              {[0, 1, 2, 3].map((optionIndex) => (
                <div key={optionIndex} className="flex items-center space-x-3">
                  <div className="flex items-center space-x-2">
                    <input
                      type="radio"
                      name={`correct-${index}`}
                      checked={question.correctAnswer === optionIndex}
                      onChange={() => updateQuestion(index, 'correctAnswer', optionIndex)}
                      className="w-4 h-4 text-blue-600"
                    />
                    <span className="text-sm font-medium text-gray-700">
                      {String.fromCharCode(65 + optionIndex)}.
                    </span>
                  </div>
                  <input
                    type="text"
                    value={question.options?.[optionIndex] || ''}
                    onChange={(e) => {
                      const newOptions = [...(question.options || ['', '', '', ''])];
                      newOptions[optionIndex] = e.target.value;
                      updateQuestion(index, 'options', newOptions);
                    }}
                    placeholder={`보기 ${optionIndex + 1} 입력...`}
                    className="flex-1 px-3 py-2 rounded-lg border border-gray-300 focus:border-blue-500 outline-none text-gray-800"
                  />
                </div>
              ))}
            </div>
            <p className="text-sm text-gray-600 mt-2">
              💡 정답인 보기를 선택하고, 각 보기의 내용을 입력하세요.
            </p>
          </div>
        )}

        {/* 해설 */}
        <div>
          <label className="block text-lg font-medium text-gray-700 mb-3">
            💡 해설 (선택사항)
          </label>
          <textarea
            value={question.explanation}
            onChange={(e) => updateQuestion(index, 'explanation', e.target.value)}
            placeholder="문제 해설을 입력하세요..."
            className="w-full px-4 py-3 rounded-2xl border border-gray-300 focus:border-blue-500 outline-none resize-none text-gray-800"
            rows={2}
          />
        </div>
      </div>
    );
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-purple-100 via-pink-50 to-indigo-100">
      {/* 메인 컨텐츠 */}
      <div className="max-w-4xl mx-auto p-4">
        <div className="pt-8">
          {/* 단어 선택 섹션 */}
          <div className="bg-white/90 backdrop-blur-sm rounded-3xl p-6 shadow-xl border border-blue-200 mb-6">
            <h2 className="text-xl font-bold text-gray-800 mb-4">📚 단어 선택</h2>
            <p className="text-gray-600 mb-4">문제에 사용할 단어들을 선택하세요.</p>
            
            {loading ? (
              <div className="text-center py-4">
                <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500 mx-auto mb-2"></div>
                <p className="text-gray-600">단어 목록을 불러오는 중...</p>
              </div>
            ) : (
              <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-3 max-h-60 overflow-y-auto">

              </div>
            )}
            

          </div>

          {/* 현재 문제만 표시 */}
          {questions.length > 0 && questions[currentQuestion] ? (
            renderQuestionEditor(questions[currentQuestion], currentQuestion)
          ) : (
            <div className="bg-white/90 backdrop-blur-sm rounded-3xl p-8 shadow-xl border border-blue-200">
              <div className="text-center">
                <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500 mx-auto mb-4"></div>
                <p className="text-gray-600">문제를 로딩 중입니다...</p>
              </div>
            </div>
          )}
          
          {/* 하단 네비게이션 */}
          <div className="flex justify-between items-center mt-8">
            <button
              onClick={() => setCurrentQuestion(Math.max(0, currentQuestion - 1))}
              disabled={currentQuestion === 0}
              className={`px-6 py-3 rounded-2xl transition-colors ${
                currentQuestion === 0
                  ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
                  : 'bg-blue-500 hover:bg-blue-600 text-white'
              }`}
            >
              ← 이전 문제
            </button>
            
            <div className="flex space-x-2">
              {questions.map((question, index) => (
                <button
                  key={index}
                  onClick={() => setCurrentQuestion(index)}
                  className={`px-3 py-2 rounded-full font-medium transition-all ${
                    currentQuestion === index
                      ? 'bg-blue-500 text-white shadow-lg'
                      : savedQuestions[index]?.saved
                      ? 'bg-green-500 text-white hover:bg-green-600'
                      : question && question.question && question.question.trim() && question.vocabId
                      ? 'bg-yellow-400 text-yellow-800 hover:bg-yellow-500'
                      : 'bg-gray-200 text-gray-500 hover:bg-gray-300'
                  }`}
                  title={
                    currentQuestion === index
                      ? '현재 문제'
                      : savedQuestions[index]?.saved 
                      ? '저장됨' 
                      : question && question.question && question.question.trim() && question.vocabId
                      ? '수정됨 (저장 필요)'
                      : !question.vocabId
                      ? '단어장 선택 필요'
                      : '미완성'
                  }
                >
                  {index + 1}
                </button>
              ))}
            </div>
            
            <div className="flex space-x-4">
              {currentQuestion < questions.length - 1 ? (
                <button
                  onClick={saveCurrentQuestion}
                  disabled={savingQuestion || !questions[currentQuestion]?.question?.trim() || !questions[currentQuestion]?.vocabId}
                  className={`px-6 py-3 rounded-2xl transition-colors ${
                    savingQuestion || !questions[currentQuestion]?.question?.trim() || !questions[currentQuestion]?.vocabId
                      ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
                      : 'bg-green-500 hover:bg-green-600 text-white'
                  }`}
                >
                  {savingQuestion ? '💾 저장 중...' : '💾 저장하고 다음문제 →'}
                </button>
              ) : (
                <button
                  onClick={saveCurrentQuestion}
                  disabled={savingQuestion || !questions[currentQuestion]?.question?.trim() || !questions[currentQuestion]?.vocabId}
                  className={`px-6 py-3 rounded-2xl transition-colors ${
                    savingQuestion || !questions[currentQuestion]?.question?.trim() || !questions[currentQuestion]?.vocabId
                      ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
                      : 'bg-green-500 hover:bg-green-600 text-white'
                  }`}
                >
                  {savingQuestion ? '💾 저장 중...' : '💾 마지막 문제 저장'}
                </button>
              )}
              
              <button
                onClick={() => setCurrentQuestion(Math.min(questions.length - 1, currentQuestion + 1))}
                disabled={currentQuestion === questions.length - 1}
                className={`px-6 py-3 rounded-2xl transition-colors ${
                  currentQuestion === questions.length - 1
                    ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
                    : 'bg-blue-500 hover:bg-blue-600 text-white'
                }`}
              >
                다음 문제 →
              </button>
              
              <button
                onClick={handleSubmit}
                disabled={!isAllQuestionsSaved()}
                className={`px-6 py-3 rounded-2xl transition-colors ${
                  isAllQuestionsSaved()
                    ? 'bg-gradient-to-r from-green-500 to-blue-600 text-white hover:shadow-lg'
                    : 'bg-gray-300 text-gray-500 cursor-not-allowed'
                }`}
                title={
                  isAllQuestionsSaved() 
                    ? '퀴즈 완성하기' 
                    : `저장되지 않은 문제: ${questions.length - savedQuestions.filter(q => q?.saved).length}개`
                }
              >
                🎯 퀴즈 완성
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
