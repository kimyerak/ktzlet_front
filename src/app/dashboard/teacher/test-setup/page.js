'use client';

import { useAuth } from '../../../contexts/AuthContext';
import { useRouter, useSearchParams } from 'next/navigation';
import { useEffect, useState } from 'react';
import TestSetup from '../../../pages/teacher/TestSetup';
import VocabSelection from '../../../pages/teacher/VocabSelection';
import TestCreation from '../../../pages/teacher/TestCreation';
import { quizService } from '../../../services/apiService';
import { questionService } from '../../../services/apiService';
import { vocabService } from '../../../services/apiService';

export default function TestSetupPage() {
  const { user, loading } = useAuth();
  const router = useRouter();
  const searchParams = useSearchParams();
  const [currentStep, setCurrentStep] = useState(1); // 1: setup, 2: vocab, 3: creation
  const [testConfig, setTestConfig] = useState(null);
  const [initialConfig, setInitialConfig] = useState(null);

  useEffect(() => {
    if (!loading && !user) {
      router.push('/');
    } else if (!loading && user && user.type !== 'teacher') {
      router.push('/dashboard');
    }
  }, [user, loading, router]);

  useEffect(() => {
    // URL 파라미터에서 편집 데이터 읽기
    const editParam = searchParams.get('edit');
    const configParam = searchParams.get('config');
    const autoGeneratedParam = searchParams.get('autoGenerated');
    
    if (editParam) {
      try {
        const editData = JSON.parse(decodeURIComponent(editParam));
        console.log('편집 모드 데이터:', editData);
        console.log('편집 모드 ID:', editData.id);
        
        // 편집 모드임을 명확히 표시
        const editConfigWithFlag = {
          ...editData,
          isEditMode: true,
          id: editData.id // id가 확실히 포함되도록
        };
        
        console.log('편집 모드 설정:', editConfigWithFlag);
        setInitialConfig(editConfigWithFlag);
        setTestConfig(editConfigWithFlag);
        // 편집 모드일 때는 바로 문제 작성 단계로
        setCurrentStep(3);
      } catch (error) {
        console.error('편집 데이터 파싱 오류:', error);
      }
    } else if (configParam) {
      try {
        const configData = JSON.parse(decodeURIComponent(configParam));
        setTestConfig(configData);
        // vocab이 이미 선택되었다면 문제 작성 단계로
        if (configData.selectedVocabs) {
          setCurrentStep(3);
        } else {
          setCurrentStep(2);
        }
      } catch (error) {
        console.error('설정 데이터 파싱 오류:', error);
      }
    } else if (autoGeneratedParam) {
      try {
        const autoGeneratedData = JSON.parse(decodeURIComponent(autoGeneratedParam));
        console.log('자동 생성 데이터:', autoGeneratedData);
        
        // 자동 생성 모드임을 명확히 표시
        const now = new Date();
        const oneHourLater = new Date(now.getTime() + 60 * 60 * 1000);
        
        const autoConfigWithFlag = {
          ...autoGeneratedData,
          isAutoGenerated: true,
                  // 기본 퀴즈 설정 추가
        title: `자동 생성 퀴즈 - ${new Date().toLocaleDateString()}`,
        numofquestion: autoGeneratedData.autoGeneratedQuestions?.length || 0,
        time_limit_sec: 1800, // 30분 기본값
        target_score: 70, // 70점 기본값
        open_at: '2025-08-01T00:00', // 2025.8.1 기본값
        close_at: '2025-08-31T23:59' // 2025.8.31 기본값
        };
        
        console.log('자동 생성 설정:', autoConfigWithFlag);
        setInitialConfig(autoConfigWithFlag);
        setTestConfig(autoConfigWithFlag);
        // 자동 생성 모드일 때는 1단계(상세정보 설정)부터 시작
        setCurrentStep(1);
      } catch (error) {
        console.error('자동 생성 데이터 파싱 오류:', error);
      }
    }
  }, [searchParams]);

  // 자동 생성 모드에서 퀴즈와 문제들을 생성하는 함수
  const createQuizWithQuestions = async (config) => {
    try {
      console.log('자동 생성 퀴즈 생성 시작:', config);
      
      // 1. 자동 생성된 단어들을 백엔드에 저장 (중복 처리)
      const savedVocabs = [];
      if (config.autoGeneratedVocabs && config.autoGeneratedVocabs.length > 0) {
        console.log('자동 생성된 단어들 저장 시작...');
        for (const vocab of config.autoGeneratedVocabs) {
          try {
            // 먼저 기존 단어가 있는지 확인
            let existingVocab = null;
            try {
              const searchResults = await vocabService.searchVocabByWord(vocab.word);
              existingVocab = searchResults.find(v => v.word.toLowerCase() === vocab.word.toLowerCase());
            } catch (searchError) {
              console.log(`단어 검색 실패: ${vocab.word}`, searchError);
            }
            
            let savedVocab;
            if (existingVocab) {
              // 기존 단어가 있으면 그대로 사용
              savedVocab = existingVocab;
              console.log(`기존 단어 사용: ${vocab.word} (ID: ${existingVocab.id})`);
            } else {
              // 기존 단어가 없으면 새로 저장
              const response = await vocabService.createVocab({
                word: vocab.word,
                definition: vocab.definition
              });
              savedVocab = response.data || response;
              console.log(`새 단어 저장 완료: ${vocab.word} (ID: ${savedVocab.id})`);
            }
            
            if (savedVocab && savedVocab.id) {
              savedVocabs.push(savedVocab);
            } else {
              console.error(`단어 처리 실패 - ID 없음: ${vocab.word}`);
            }
          } catch (error) {
            console.error(`단어 처리 실패: ${vocab.word}`, error);
            
            // 중복 단어 에러인 경우 기존 단어를 찾아서 사용
            if (error.message && error.message.includes('이미 존재하는 단어입니다')) {
              try {
                console.log(`중복 단어 에러 - 기존 단어 검색: ${vocab.word}`);
                const searchResults = await vocabService.searchVocabByWord(vocab.word);
                const existingVocab = searchResults.find(v => v.word.toLowerCase() === vocab.word.toLowerCase());
                
                if (existingVocab) {
                  savedVocabs.push(existingVocab);
                  console.log(`중복 단어 처리 완료: ${vocab.word} (ID: ${existingVocab.id})`);
                } else {
                  console.error(`중복 단어 에러였지만 기존 단어를 찾을 수 없음: ${vocab.word}`);
                }
              } catch (searchError) {
                console.error(`중복 단어 검색 실패: ${vocab.word}`, searchError);
              }
            }
            // 다른 에러는 무시하고 계속 진행
          }
        }
      }
      
      // 2. 퀴즈 생성
      const quizData = {
        title: config.title,
        numOfQuestions: config.autoGeneratedQuestions?.length || 0, // 필드명 수정
        timeLimitSec: config.time_limit_sec, // 필드명 수정
        targetScore: config.target_score, // 필드명 수정
        openAt: config.open_at || null, // 필드명 수정
        closeAt: config.close_at || null, // 필드명 수정
        createdBy: user.id
      };
      
      // 날짜 유효성 검사 (2025.8.1 ~ 2025.8.31 기본값 유지)
      if (!quizData.open_at || !quizData.close_at) {
        console.warn('날짜가 설정되지 않았습니다. 기본값으로 설정합니다.');
        quizData.open_at = '2025-08-01T00:00';
        quizData.close_at = '2025-08-31T23:59';
      }
      
      // 날짜 순서 검사만 수행 (기본값 변경하지 않음)
      if (quizData.open_at && quizData.close_at) {
        const openDate = new Date(quizData.open_at);
        const closeDate = new Date(quizData.close_at);
        
        if (closeDate <= openDate) {
          console.warn('마감일이 시작일보다 빠릅니다. 기본값으로 설정합니다.');
          quizData.open_at = '2025-08-01T00:00';
          quizData.close_at = '2025-08-31T23:59';
        }
      }
      
      console.log('퀴즈 생성 데이터:', quizData);
      let createdQuiz;
      try {
        createdQuiz = await quizService.createQuiz(quizData);
        console.log('퀴즈 생성 완료:', createdQuiz);
      } catch (error) {
        console.error('퀴즈 생성 실패 - 상세 오류:', error);
        console.error('퀴즈 데이터:', JSON.stringify(quizData, null, 2));
        throw error;
      }
      
      // 3. 문제들 생성
      if (config.autoGeneratedQuestions && config.autoGeneratedQuestions.length > 0) {
        console.log('자동 생성된 문제들 생성 시작...');
        for (const question of config.autoGeneratedQuestions) {
          // 저장된 단어에서 vocabId 찾기 (더 정확한 매핑)
          let vocabId = null;
          
          // 1. question.vocab.word로 찾기
          if (question.vocab?.word) {
            const vocab = savedVocabs.find(v => v.word.toLowerCase() === question.vocab.word.toLowerCase());
            if (vocab) {
              vocabId = vocab.id;
              console.log(`vocabId 찾음 (vocab.word): ${question.vocab.word} -> ${vocabId}`);
            }
          }
          
          // 2. question.correctAnswer로 찾기 (Dictation 문제의 경우)
          if (!vocabId && question.correctAnswer && typeof question.correctAnswer === 'string') {
            const vocab = savedVocabs.find(v => v.word.toLowerCase() === question.correctAnswer.toLowerCase());
            if (vocab) {
              vocabId = vocab.id;
              console.log(`vocabId 찾음 (correctAnswer): ${question.correctAnswer} -> ${vocabId}`);
            }
          }
          
          // 3. question.stem에서 단어 추출해서 찾기
          if (!vocabId && question.stem) {
            const stemWords = question.stem.split(' ').filter(word => word.length > 2);
            for (const word of stemWords) {
              const vocab = savedVocabs.find(v => v.word.toLowerCase() === word.toLowerCase());
              if (vocab) {
                vocabId = vocab.id;
                console.log(`vocabId 찾음 (stem): ${word} -> ${vocabId}`);
                break;
              }
            }
          }
          
          // 4. 여전히 null이면 문제 내용에서 단어 추출 시도
          if (!vocabId) {
            console.warn(`vocabId를 찾을 수 없습니다. 문제: ${question.stem || question.question}`);
            console.log('savedVocabs:', savedVocabs);
            console.log('question.vocab:', question.vocab);
            
                          // 문제 내용에서 영어 단어 추출 시도
              const questionText = question.stem || question.question || '';
              const englishWordMatch = questionText.match(/\b([a-zA-Z]+)\b/);
              
              // 한국어 키워드 매칭 시도
              if (!englishWordMatch) {
                const koreanKeywords = {
                  '벤치': 'bench',
                  '공원': 'park',
                  '정원': 'garden',
                  '소풍': 'picnic',
                  '여성': 'female',
                  '남성': 'male',
                  '성별': 'gender',
                  '여성적인': 'feminine',
                  '남성적인': 'masculine',
                  '의상': 'clothes',
                  '옷': 'clothes',
                  '음식': 'food',
                  '음료': 'drink',
                  '샌드위치': 'sandwich',
                  '스파게티': 'spaghetti',
                  '피자': 'pizza',
                  '햄버거': 'hamburger',
                  '샐러드': 'salad',
                  '시간': 'time',
                  '날짜': 'date',
                  '월': 'month',
                  '년': 'year',
                  '주': 'week',
                  '일': 'day',
                  '시': 'hour',
                  '분': 'minute',
                  '초': 'second',
                  '색': 'color',
                  '색깔': 'color',
                  '빨간': 'red',
                  '빨강': 'red',
                  '파란': 'blue',
                  '파랑': 'blue',
                  '노란': 'yellow',
                  '노랑': 'yellow',
                  '초록': 'green',
                  '녹색': 'green',
                  '보라': 'purple',
                  '보라색': 'purple',
                  '검은': 'black',
                  '검정': 'black',
                  '흰': 'white',
                  '하얀': 'white',
                  '큰': 'big',
                  '크다': 'big',
                  '작은': 'small',
                  '작다': 'small',
                  '긴': 'long',
                  '길다': 'long',
                  '짧은': 'short',
                  '짧다': 'short',
                  '높은': 'high',
                  '높다': 'high',
                  '낮은': 'low',
                  '낮다': 'low',
                  '좋은': 'good',
                  '좋다': 'good',
                  '나쁜': 'bad',
                  '나쁘다': 'bad',
                  '예쁜': 'beautiful',
                  '아름다운': 'beautiful',
                  '못생긴': 'ugly',
                  '추한': 'ugly',
                  '행복한': 'happy',
                  '기쁜': 'happy',
                  '슬픈': 'sad',
                  '우는': 'sad',
                  '화난': 'angry',
                  '화가난': 'angry',
                  '더운': 'hot',
                  '뜨거운': 'hot',
                  '추운': 'cold',
                  '차가운': 'cold',
                  '따뜻한': 'warm',
                  '온난한': 'warm',
                  '시원한': 'cool',
                  '서늘한': 'cool',
                  '새로운': 'new',
                  '새': 'new',
                  '오래된': 'old',
                  '낡은': 'old',
                  '젊은': 'young',
                  '어린': 'young',
                  '신선한': 'fresh',
                  '비빔밥': 'bibimbap',
                  '전': 'jeon',
                  '김치': 'kimchi',
                  '불고기': 'bulgogi',
                  '라면': 'ramen',
                  '떡볶이': 'tteokbokki',
                  '삼겹살': 'samgyeopsal',
                  '치킨': 'chicken',
                  '파스타': 'pasta',
                  '스테이크': 'steak',
                  '샤브샤브': 'shabu-shabu',
                  '초밥': 'sushi',
                  '우동': 'udon',
                  '덮밥': 'donburi',
                  '김밥': 'kimbap',
                  '된장': 'doenjang',
                  '고추장': 'gochujang',
                  '간장': 'soy sauce',
                  '참기름': 'sesame oil',
                  '마늘': 'garlic',
                  '양파': 'onion',
                  '당근': 'carrot',
                  '양배추': 'cabbage',
                  '상추': 'lettuce',
                  '오이': 'cucumber',
                  '토마토': 'tomato',
                  '감자': 'potato',
                  '고구마': 'sweet potato'
                };
                
                for (const [korean, english] of Object.entries(koreanKeywords)) {
                  if (questionText.includes(korean)) {
                    console.log(`한국어 키워드 매칭: ${korean} -> ${english}`);
                    
                    // savedVocabs에서 매칭되는 단어 찾기
                    const matchedVocab = savedVocabs.find(vocab => 
                      vocab.word.toLowerCase() === english.toLowerCase()
                    );
                    
                    if (matchedVocab) {
                      vocabId = matchedVocab.id;
                      console.log(`한국어 키워드로 vocabId 매칭 성공: ${korean} -> ${english} -> ${vocabId}`);
                      break;
                    }
                  }
                }
              }
            
            if (englishWordMatch) {
              const extractedWord = englishWordMatch[1].toLowerCase();
              console.log(`문제에서 추출한 단어: ${extractedWord}`);
              
              // savedVocabs에서 매칭되는 단어 찾기
              const matchedVocab = savedVocabs.find(vocab => 
                vocab.word.toLowerCase() === extractedWord
              );
              
              if (matchedVocab) {
                vocabId = matchedVocab.id;
                console.log(`추출한 단어로 vocabId 매칭 성공: ${extractedWord} -> ${vocabId}`);
              } else {
                console.log(`추출한 단어 '${extractedWord}'가 savedVocabs에 없음`);
                vocabId = savedVocabs.length > 0 ? savedVocabs[0].id : 1;
                console.log(`vocabId를 기본값 ${vocabId}로 설정합니다.`);
              }
            } else {
              vocabId = savedVocabs.length > 0 ? savedVocabs[0].id : 1;
              console.log(`vocabId를 기본값 ${vocabId}로 설정합니다.`);
            }
          }
          
          // 문제 타입 매핑 (백엔드 enum에 맞춤)
          let mappedType = question.type;
          if (question.type === 'DICTATION') mappedType = 'DICTATION';
          else if (question.type === 'MULTIPLE') mappedType = 'MULTIPLE'; // MULTIPLE_CHOICE가 아니라 MULTIPLE
          else if (question.type === 'OX') mappedType = 'OX';
          
          // stem 필드가 null이 되지 않도록 기본값 설정
          console.log(`문제 원본 데이터:`, question);
          console.log(`question.question:`, question.question);
          console.log(`question.stem:`, question.stem);
          
          const stemValue = question.question || question.stem || '문제 내용이 없습니다';
          console.log(`최종 stem 값:`, stemValue);
          
          const questionData = {
            quizId: createdQuiz.id,
            type: mappedType,
            stem: stemValue,
            correctAnswer: question.type === 'MULTIPLE' ? 
            (question.correctAnswer ? parseInt(question.correctAnswer) : 0) : 
            question.correctAnswer,
            explanation: question.explanation,
            points: question.points || 1,
            vocabId: vocabId,
            options: question.type === 'MULTIPLE' ? (question.options || []) : null
          };
          
          console.log('문제 생성 데이터:', questionData);
          console.log('options 필드 확인:', questionData.options);
          console.log('correctAnswer 타입 확인:', typeof questionData.correctAnswer, questionData.correctAnswer);
        console.log('원본 correctAnswer:', question.correctAnswer);
        console.log('문제 타입:', question.type);
          try {
            await questionService.createQuestion(questionData);
            console.log(`문제 생성 완료: ${questionData.question}`);
          } catch (error) {
            console.error(`문제 생성 실패: ${questionData.question}`, error);
            console.error('문제 데이터:', JSON.stringify(questionData, null, 2));
            throw error;
          }
        }
      }
      
      console.log('자동 생성 퀴즈 완성!');
      alert('🎉 AI 자동 생성 퀴즈가 성공적으로 생성되었습니다!');
      router.push('/dashboard/teacher');
      
    } catch (error) {
      console.error('자동 생성 퀴즈 생성 오류:', error);
      alert('퀴즈 생성 중 오류가 발생했습니다. 다시 시도해주세요.');
    }
  };

  if (loading) {
    return <div>로딩 중...</div>;
  }

  if (!user || user.type !== 'teacher') {
    return null;
  }

  // 1단계: 기본 설정
  if (currentStep === 1) {
    return (
      <TestSetup
        initialConfig={initialConfig}
        onNext={async (config) => {
          if (config.isAutoGenerated) {
            // 자동 생성 모드: 바로 퀴즈 생성
            console.log('자동 생성 모드: 바로 퀴즈 생성 시작');
            await createQuizWithQuestions(config);
          } else {
            // 일반 모드: 2단계로 이동
            setTestConfig(config);
            setCurrentStep(2);
          }
        }}
        onBack={() => router.push('/dashboard/teacher')}
      />
    );
  }

  // 2단계: 단어 선택
  if (currentStep === 2) {
    return (
      <VocabSelection
        testConfig={testConfig}
        onNext={async (configWithVocabs) => {
          try {
            console.log('단어 선택 완료:', configWithVocabs);
            
            // 퀴즈 생성 없이 단어 정보만 전달
            setTestConfig(configWithVocabs);
            setCurrentStep(3);
            
          } catch (error) {
            console.error('단어 선택 처리 오류:', error);
            alert('단어 선택 처리 중 오류가 발생했습니다. 다시 시도해주세요.');
          }
        }}
        onBack={() => setCurrentStep(1)}
        user={user}
      />
    );
  }

  // 3단계: 문제 작성
  if (currentStep === 3) {
    return (
      <TestCreation
        testConfig={testConfig}
        onSubmit={async (submittedConfig) => {
          console.log('TestCreation에서 제출됨:', submittedConfig);
          
          try {
            // 백엔드 연결 확인
            try {
              const testResponse = await fetch('/api/test');
              if (!testResponse.ok) {
                throw new Error('백엔드 서버에 연결할 수 없습니다.');
              }
              console.log('백엔드 연결 확인됨');
            } catch (connectionError) {
              console.error('백엔드 연결 오류:', connectionError);
              alert('백엔드 서버에 연결할 수 없습니다. 서버가 실행 중인지 확인해주세요.');
              return;
            }
            
            const quizId = submittedConfig.id;
            
            if (!quizId) {
              throw new Error('퀴즈 ID가 없습니다. 다시 시도해주세요.');
            }
            
            console.log('기존 퀴즈에 문제 추가:', quizId);
            
            // TestCreation에서 이미 문제가 생성되었으므로 중복 생성 방지
            console.log('TestCreation에서 이미 문제가 생성되었습니다. 중복 생성을 건너뜁니다.');
            
            alert('🎉 퀴즈가 성공적으로 완성되었습니다!');
            router.push('/dashboard/teacher');
            
          } catch (error) {
            console.error('퀴즈 처리 오류:', error);
            alert('❌ 퀴즈 처리 중 오류가 발생했습니다.');
          }
        }}
        onBack={async () => {
          // 나가기 시도 시 경고
          const completedQuestions = testConfig?.questions?.filter(q => 
            q && q.question && q.question.trim() && q.vocabId && q.correctAnswer !== undefined && q.correctAnswer !== null && q.correctAnswer !== ''
          ) || [];
          
          if (completedQuestions.length < (testConfig?.questions?.length || 0)) {
            const incompleteCount = (testConfig?.questions?.length || 0) - completedQuestions.length;
            const confirmExit = confirm(
              `아직 ${incompleteCount}개의 질문이 모두 작성되지 않았어요!\n\n그래도 나가시겠어요? 그러면 저장되지 않습니다!`
            );
            
            if (confirmExit) {
              // 퀴즈 삭제
              if (testConfig?.id) {
                try {
                  console.log('미완성 퀴즈 삭제 시작:', testConfig.id);
                  await quizService.deleteQuiz(testConfig.id);
                  console.log('미완성 퀴즈 삭제 완료');
                } catch (error) {
                  console.error('퀴즈 삭제 오류:', error);
                }
              }
              setCurrentStep(2);
            }
          } else {
            setCurrentStep(2);
          }
        }}
        user={user}
      />
    );
  }

  return null;
} 