'use client';

import { useAuth } from '../../../contexts/AuthContext';
import { useRouter, useSearchParams } from 'next/navigation';
import { useEffect, useState } from 'react';
import TestSetup from '../../../pages/teacher/TestSetup';
import VocabSelection from '../../../pages/teacher/VocabSelection';
import TestCreation from '../../../pages/teacher/TestCreation';
import { quizService } from '../../../services/apiService';
import { questionService } from '../../../services/apiService';
import { vocabService } from '../../../services/apiService';

export default function TestSetupPage() {
  const { user, loading } = useAuth();
  const router = useRouter();
  const searchParams = useSearchParams();
  const [currentStep, setCurrentStep] = useState(1); // 1: setup, 2: vocab, 3: creation
  const [testConfig, setTestConfig] = useState(null);
  const [initialConfig, setInitialConfig] = useState(null);

  useEffect(() => {
    if (!loading && !user) {
      router.push('/');
    } else if (!loading && user && user.type !== 'teacher') {
      router.push('/dashboard');
    }
  }, [user, loading, router]);

  useEffect(() => {
    // URL íŒŒë¼ë¯¸í„°ì—ì„œ í¸ì§‘ ë°ì´í„° ì½ê¸°
    const editParam = searchParams.get('edit');
    const configParam = searchParams.get('config');
    const autoGeneratedParam = searchParams.get('autoGenerated');
    
    if (editParam) {
      try {
        const editData = JSON.parse(decodeURIComponent(editParam));
        console.log('í¸ì§‘ ëª¨ë“œ ë°ì´í„°:', editData);
        console.log('í¸ì§‘ ëª¨ë“œ ID:', editData.id);
        
        // í¸ì§‘ ëª¨ë“œì„ì„ ëª…í™•íˆ í‘œì‹œ
        const editConfigWithFlag = {
          ...editData,
          isEditMode: true,
          id: editData.id // idê°€ í™•ì‹¤íˆ í¬í•¨ë˜ë„ë¡
        };
        
        console.log('í¸ì§‘ ëª¨ë“œ ì„¤ì •:', editConfigWithFlag);
        setInitialConfig(editConfigWithFlag);
        setTestConfig(editConfigWithFlag);
        // í¸ì§‘ ëª¨ë“œì¼ ë•ŒëŠ” ë°”ë¡œ ë¬¸ì œ ì‘ì„± ë‹¨ê³„ë¡œ
        setCurrentStep(3);
      } catch (error) {
        console.error('í¸ì§‘ ë°ì´í„° íŒŒì‹± ì˜¤ë¥˜:', error);
      }
    } else if (configParam) {
      try {
        const configData = JSON.parse(decodeURIComponent(configParam));
        setTestConfig(configData);
        // vocabì´ ì´ë¯¸ ì„ íƒë˜ì—ˆë‹¤ë©´ ë¬¸ì œ ì‘ì„± ë‹¨ê³„ë¡œ
        if (configData.selectedVocabs) {
          setCurrentStep(3);
        } else {
          setCurrentStep(2);
        }
      } catch (error) {
        console.error('ì„¤ì • ë°ì´í„° íŒŒì‹± ì˜¤ë¥˜:', error);
      }
    } else if (autoGeneratedParam) {
      try {
        const autoGeneratedData = JSON.parse(decodeURIComponent(autoGeneratedParam));
        console.log('ìë™ ìƒì„± ë°ì´í„°:', autoGeneratedData);
        
        // ìë™ ìƒì„± ëª¨ë“œì„ì„ ëª…í™•íˆ í‘œì‹œ
        const now = new Date();
        const oneHourLater = new Date(now.getTime() + 60 * 60 * 1000);
        
        const autoConfigWithFlag = {
          ...autoGeneratedData,
          isAutoGenerated: true,
                  // ê¸°ë³¸ í€´ì¦ˆ ì„¤ì • ì¶”ê°€
        title: `ìë™ ìƒì„± í€´ì¦ˆ - ${new Date().toLocaleDateString()}`,
        numofquestion: autoGeneratedData.autoGeneratedQuestions?.length || 0,
        time_limit_sec: 1800, // 30ë¶„ ê¸°ë³¸ê°’
        target_score: 70, // 70ì  ê¸°ë³¸ê°’
        open_at: '2025-08-01T00:00', // 2025.8.1 ê¸°ë³¸ê°’
        close_at: '2025-08-31T23:59' // 2025.8.31 ê¸°ë³¸ê°’
        };
        
        console.log('ìë™ ìƒì„± ì„¤ì •:', autoConfigWithFlag);
        setInitialConfig(autoConfigWithFlag);
        setTestConfig(autoConfigWithFlag);
        // ìë™ ìƒì„± ëª¨ë“œì¼ ë•ŒëŠ” 1ë‹¨ê³„(ìƒì„¸ì •ë³´ ì„¤ì •)ë¶€í„° ì‹œì‘
        setCurrentStep(1);
      } catch (error) {
        console.error('ìë™ ìƒì„± ë°ì´í„° íŒŒì‹± ì˜¤ë¥˜:', error);
      }
    }
  }, [searchParams]);

  // ìë™ ìƒì„± ëª¨ë“œì—ì„œ í€´ì¦ˆì™€ ë¬¸ì œë“¤ì„ ìƒì„±í•˜ëŠ” í•¨ìˆ˜
  const createQuizWithQuestions = async (config) => {
    try {
      console.log('ìë™ ìƒì„± í€´ì¦ˆ ìƒì„± ì‹œì‘:', config);
      
      // 1. ìë™ ìƒì„±ëœ ë‹¨ì–´ë“¤ì„ ë°±ì—”ë“œì— ì €ì¥ (ì¤‘ë³µ ì²˜ë¦¬)
      const savedVocabs = [];
      if (config.autoGeneratedVocabs && config.autoGeneratedVocabs.length > 0) {
        console.log('ìë™ ìƒì„±ëœ ë‹¨ì–´ë“¤ ì €ì¥ ì‹œì‘...');
        for (const vocab of config.autoGeneratedVocabs) {
          try {
            // ë¨¼ì € ê¸°ì¡´ ë‹¨ì–´ê°€ ìˆëŠ”ì§€ í™•ì¸
            let existingVocab = null;
            try {
              const searchResults = await vocabService.searchVocabByWord(vocab.word);
              existingVocab = searchResults.find(v => v.word.toLowerCase() === vocab.word.toLowerCase());
            } catch (searchError) {
              console.log(`ë‹¨ì–´ ê²€ìƒ‰ ì‹¤íŒ¨: ${vocab.word}`, searchError);
            }
            
            let savedVocab;
            if (existingVocab) {
              // ê¸°ì¡´ ë‹¨ì–´ê°€ ìˆìœ¼ë©´ ê·¸ëŒ€ë¡œ ì‚¬ìš©
              savedVocab = existingVocab;
              console.log(`ê¸°ì¡´ ë‹¨ì–´ ì‚¬ìš©: ${vocab.word} (ID: ${existingVocab.id})`);
            } else {
              // ê¸°ì¡´ ë‹¨ì–´ê°€ ì—†ìœ¼ë©´ ìƒˆë¡œ ì €ì¥
              const response = await vocabService.createVocab({
                word: vocab.word,
                definition: vocab.definition
              });
              savedVocab = response.data || response;
              console.log(`ìƒˆ ë‹¨ì–´ ì €ì¥ ì™„ë£Œ: ${vocab.word} (ID: ${savedVocab.id})`);
            }
            
            if (savedVocab && savedVocab.id) {
              savedVocabs.push(savedVocab);
            } else {
              console.error(`ë‹¨ì–´ ì²˜ë¦¬ ì‹¤íŒ¨ - ID ì—†ìŒ: ${vocab.word}`);
            }
          } catch (error) {
            console.error(`ë‹¨ì–´ ì²˜ë¦¬ ì‹¤íŒ¨: ${vocab.word}`, error);
            
            // ì¤‘ë³µ ë‹¨ì–´ ì—ëŸ¬ì¸ ê²½ìš° ê¸°ì¡´ ë‹¨ì–´ë¥¼ ì°¾ì•„ì„œ ì‚¬ìš©
            if (error.message && error.message.includes('ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ë‹¨ì–´ì…ë‹ˆë‹¤')) {
              try {
                console.log(`ì¤‘ë³µ ë‹¨ì–´ ì—ëŸ¬ - ê¸°ì¡´ ë‹¨ì–´ ê²€ìƒ‰: ${vocab.word}`);
                const searchResults = await vocabService.searchVocabByWord(vocab.word);
                const existingVocab = searchResults.find(v => v.word.toLowerCase() === vocab.word.toLowerCase());
                
                if (existingVocab) {
                  savedVocabs.push(existingVocab);
                  console.log(`ì¤‘ë³µ ë‹¨ì–´ ì²˜ë¦¬ ì™„ë£Œ: ${vocab.word} (ID: ${existingVocab.id})`);
                } else {
                  console.error(`ì¤‘ë³µ ë‹¨ì–´ ì—ëŸ¬ì˜€ì§€ë§Œ ê¸°ì¡´ ë‹¨ì–´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ: ${vocab.word}`);
                }
              } catch (searchError) {
                console.error(`ì¤‘ë³µ ë‹¨ì–´ ê²€ìƒ‰ ì‹¤íŒ¨: ${vocab.word}`, searchError);
              }
            }
            // ë‹¤ë¥¸ ì—ëŸ¬ëŠ” ë¬´ì‹œí•˜ê³  ê³„ì† ì§„í–‰
          }
        }
      }
      
      // 2. í€´ì¦ˆ ìƒì„±
      const quizData = {
        title: config.title,
        numOfQuestions: config.autoGeneratedQuestions?.length || 0, // í•„ë“œëª… ìˆ˜ì •
        timeLimitSec: config.time_limit_sec, // í•„ë“œëª… ìˆ˜ì •
        targetScore: config.target_score, // í•„ë“œëª… ìˆ˜ì •
        openAt: config.open_at || null, // í•„ë“œëª… ìˆ˜ì •
        closeAt: config.close_at || null, // í•„ë“œëª… ìˆ˜ì •
        createdBy: user.id
      };
      
      // ë‚ ì§œ ìœ íš¨ì„± ê²€ì‚¬ (2025.8.1 ~ 2025.8.31 ê¸°ë³¸ê°’ ìœ ì§€)
      if (!quizData.open_at || !quizData.close_at) {
        console.warn('ë‚ ì§œê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ê¸°ë³¸ê°’ìœ¼ë¡œ ì„¤ì •í•©ë‹ˆë‹¤.');
        quizData.open_at = '2025-08-01T00:00';
        quizData.close_at = '2025-08-31T23:59';
      }
      
      // ë‚ ì§œ ìˆœì„œ ê²€ì‚¬ë§Œ ìˆ˜í–‰ (ê¸°ë³¸ê°’ ë³€ê²½í•˜ì§€ ì•ŠìŒ)
      if (quizData.open_at && quizData.close_at) {
        const openDate = new Date(quizData.open_at);
        const closeDate = new Date(quizData.close_at);
        
        if (closeDate <= openDate) {
          console.warn('ë§ˆê°ì¼ì´ ì‹œì‘ì¼ë³´ë‹¤ ë¹ ë¦…ë‹ˆë‹¤. ê¸°ë³¸ê°’ìœ¼ë¡œ ì„¤ì •í•©ë‹ˆë‹¤.');
          quizData.open_at = '2025-08-01T00:00';
          quizData.close_at = '2025-08-31T23:59';
        }
      }
      
      console.log('í€´ì¦ˆ ìƒì„± ë°ì´í„°:', quizData);
      let createdQuiz;
      try {
        createdQuiz = await quizService.createQuiz(quizData);
        console.log('í€´ì¦ˆ ìƒì„± ì™„ë£Œ:', createdQuiz);
      } catch (error) {
        console.error('í€´ì¦ˆ ìƒì„± ì‹¤íŒ¨ - ìƒì„¸ ì˜¤ë¥˜:', error);
        console.error('í€´ì¦ˆ ë°ì´í„°:', JSON.stringify(quizData, null, 2));
        throw error;
      }
      
      // 3. ë¬¸ì œë“¤ ìƒì„±
      if (config.autoGeneratedQuestions && config.autoGeneratedQuestions.length > 0) {
        console.log('ìë™ ìƒì„±ëœ ë¬¸ì œë“¤ ìƒì„± ì‹œì‘...');
        for (const question of config.autoGeneratedQuestions) {
          // ì €ì¥ëœ ë‹¨ì–´ì—ì„œ vocabId ì°¾ê¸° (ë” ì •í™•í•œ ë§¤í•‘)
          let vocabId = null;
          
          // 1. question.vocab.wordë¡œ ì°¾ê¸°
          if (question.vocab?.word) {
            const vocab = savedVocabs.find(v => v.word.toLowerCase() === question.vocab.word.toLowerCase());
            if (vocab) {
              vocabId = vocab.id;
              console.log(`vocabId ì°¾ìŒ (vocab.word): ${question.vocab.word} -> ${vocabId}`);
            }
          }
          
          // 2. question.correctAnswerë¡œ ì°¾ê¸° (Dictation ë¬¸ì œì˜ ê²½ìš°)
          if (!vocabId && question.correctAnswer && typeof question.correctAnswer === 'string') {
            const vocab = savedVocabs.find(v => v.word.toLowerCase() === question.correctAnswer.toLowerCase());
            if (vocab) {
              vocabId = vocab.id;
              console.log(`vocabId ì°¾ìŒ (correctAnswer): ${question.correctAnswer} -> ${vocabId}`);
            }
          }
          
          // 3. question.stemì—ì„œ ë‹¨ì–´ ì¶”ì¶œí•´ì„œ ì°¾ê¸°
          if (!vocabId && question.stem) {
            const stemWords = question.stem.split(' ').filter(word => word.length > 2);
            for (const word of stemWords) {
              const vocab = savedVocabs.find(v => v.word.toLowerCase() === word.toLowerCase());
              if (vocab) {
                vocabId = vocab.id;
                console.log(`vocabId ì°¾ìŒ (stem): ${word} -> ${vocabId}`);
                break;
              }
            }
          }
          
          // 4. ì—¬ì „íˆ nullì´ë©´ ë¬¸ì œ ë‚´ìš©ì—ì„œ ë‹¨ì–´ ì¶”ì¶œ ì‹œë„
          if (!vocabId) {
            console.warn(`vocabIdë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë¬¸ì œ: ${question.stem || question.question}`);
            console.log('savedVocabs:', savedVocabs);
            console.log('question.vocab:', question.vocab);
            
                          // ë¬¸ì œ ë‚´ìš©ì—ì„œ ì˜ì–´ ë‹¨ì–´ ì¶”ì¶œ ì‹œë„
              const questionText = question.stem || question.question || '';
              const englishWordMatch = questionText.match(/\b([a-zA-Z]+)\b/);
              
              // í•œêµ­ì–´ í‚¤ì›Œë“œ ë§¤ì¹­ ì‹œë„
              if (!englishWordMatch) {
                const koreanKeywords = {
                  'ë²¤ì¹˜': 'bench',
                  'ê³µì›': 'park',
                  'ì •ì›': 'garden',
                  'ì†Œí’': 'picnic',
                  'ì—¬ì„±': 'female',
                  'ë‚¨ì„±': 'male',
                  'ì„±ë³„': 'gender',
                  'ì—¬ì„±ì ì¸': 'feminine',
                  'ë‚¨ì„±ì ì¸': 'masculine',
                  'ì˜ìƒ': 'clothes',
                  'ì˜·': 'clothes',
                  'ìŒì‹': 'food',
                  'ìŒë£Œ': 'drink',
                  'ìƒŒë“œìœ„ì¹˜': 'sandwich',
                  'ìŠ¤íŒŒê²Œí‹°': 'spaghetti',
                  'í”¼ì': 'pizza',
                  'í–„ë²„ê±°': 'hamburger',
                  'ìƒëŸ¬ë“œ': 'salad',
                  'ì‹œê°„': 'time',
                  'ë‚ ì§œ': 'date',
                  'ì›”': 'month',
                  'ë…„': 'year',
                  'ì£¼': 'week',
                  'ì¼': 'day',
                  'ì‹œ': 'hour',
                  'ë¶„': 'minute',
                  'ì´ˆ': 'second',
                  'ìƒ‰': 'color',
                  'ìƒ‰ê¹”': 'color',
                  'ë¹¨ê°„': 'red',
                  'ë¹¨ê°•': 'red',
                  'íŒŒë€': 'blue',
                  'íŒŒë‘': 'blue',
                  'ë…¸ë€': 'yellow',
                  'ë…¸ë‘': 'yellow',
                  'ì´ˆë¡': 'green',
                  'ë…¹ìƒ‰': 'green',
                  'ë³´ë¼': 'purple',
                  'ë³´ë¼ìƒ‰': 'purple',
                  'ê²€ì€': 'black',
                  'ê²€ì •': 'black',
                  'í°': 'white',
                  'í•˜ì–€': 'white',
                  'í°': 'big',
                  'í¬ë‹¤': 'big',
                  'ì‘ì€': 'small',
                  'ì‘ë‹¤': 'small',
                  'ê¸´': 'long',
                  'ê¸¸ë‹¤': 'long',
                  'ì§§ì€': 'short',
                  'ì§§ë‹¤': 'short',
                  'ë†’ì€': 'high',
                  'ë†’ë‹¤': 'high',
                  'ë‚®ì€': 'low',
                  'ë‚®ë‹¤': 'low',
                  'ì¢‹ì€': 'good',
                  'ì¢‹ë‹¤': 'good',
                  'ë‚˜ìœ': 'bad',
                  'ë‚˜ì˜ë‹¤': 'bad',
                  'ì˜ˆìœ': 'beautiful',
                  'ì•„ë¦„ë‹¤ìš´': 'beautiful',
                  'ëª»ìƒê¸´': 'ugly',
                  'ì¶”í•œ': 'ugly',
                  'í–‰ë³µí•œ': 'happy',
                  'ê¸°ìœ': 'happy',
                  'ìŠ¬í”ˆ': 'sad',
                  'ìš°ëŠ”': 'sad',
                  'í™”ë‚œ': 'angry',
                  'í™”ê°€ë‚œ': 'angry',
                  'ë”ìš´': 'hot',
                  'ëœ¨ê±°ìš´': 'hot',
                  'ì¶”ìš´': 'cold',
                  'ì°¨ê°€ìš´': 'cold',
                  'ë”°ëœ»í•œ': 'warm',
                  'ì˜¨ë‚œí•œ': 'warm',
                  'ì‹œì›í•œ': 'cool',
                  'ì„œëŠ˜í•œ': 'cool',
                  'ìƒˆë¡œìš´': 'new',
                  'ìƒˆ': 'new',
                  'ì˜¤ë˜ëœ': 'old',
                  'ë‚¡ì€': 'old',
                  'ì Šì€': 'young',
                  'ì–´ë¦°': 'young',
                  'ì‹ ì„ í•œ': 'fresh',
                  'ë¹„ë¹”ë°¥': 'bibimbap',
                  'ì „': 'jeon',
                  'ê¹€ì¹˜': 'kimchi',
                  'ë¶ˆê³ ê¸°': 'bulgogi',
                  'ë¼ë©´': 'ramen',
                  'ë–¡ë³¶ì´': 'tteokbokki',
                  'ì‚¼ê²¹ì‚´': 'samgyeopsal',
                  'ì¹˜í‚¨': 'chicken',
                  'íŒŒìŠ¤íƒ€': 'pasta',
                  'ìŠ¤í…Œì´í¬': 'steak',
                  'ìƒ¤ë¸Œìƒ¤ë¸Œ': 'shabu-shabu',
                  'ì´ˆë°¥': 'sushi',
                  'ìš°ë™': 'udon',
                  'ë®ë°¥': 'donburi',
                  'ê¹€ë°¥': 'kimbap',
                  'ëœì¥': 'doenjang',
                  'ê³ ì¶”ì¥': 'gochujang',
                  'ê°„ì¥': 'soy sauce',
                  'ì°¸ê¸°ë¦„': 'sesame oil',
                  'ë§ˆëŠ˜': 'garlic',
                  'ì–‘íŒŒ': 'onion',
                  'ë‹¹ê·¼': 'carrot',
                  'ì–‘ë°°ì¶”': 'cabbage',
                  'ìƒì¶”': 'lettuce',
                  'ì˜¤ì´': 'cucumber',
                  'í† ë§ˆí† ': 'tomato',
                  'ê°ì': 'potato',
                  'ê³ êµ¬ë§ˆ': 'sweet potato'
                };
                
                for (const [korean, english] of Object.entries(koreanKeywords)) {
                  if (questionText.includes(korean)) {
                    console.log(`í•œêµ­ì–´ í‚¤ì›Œë“œ ë§¤ì¹­: ${korean} -> ${english}`);
                    
                    // savedVocabsì—ì„œ ë§¤ì¹­ë˜ëŠ” ë‹¨ì–´ ì°¾ê¸°
                    const matchedVocab = savedVocabs.find(vocab => 
                      vocab.word.toLowerCase() === english.toLowerCase()
                    );
                    
                    if (matchedVocab) {
                      vocabId = matchedVocab.id;
                      console.log(`í•œêµ­ì–´ í‚¤ì›Œë“œë¡œ vocabId ë§¤ì¹­ ì„±ê³µ: ${korean} -> ${english} -> ${vocabId}`);
                      break;
                    }
                  }
                }
              }
            
            if (englishWordMatch) {
              const extractedWord = englishWordMatch[1].toLowerCase();
              console.log(`ë¬¸ì œì—ì„œ ì¶”ì¶œí•œ ë‹¨ì–´: ${extractedWord}`);
              
              // savedVocabsì—ì„œ ë§¤ì¹­ë˜ëŠ” ë‹¨ì–´ ì°¾ê¸°
              const matchedVocab = savedVocabs.find(vocab => 
                vocab.word.toLowerCase() === extractedWord
              );
              
              if (matchedVocab) {
                vocabId = matchedVocab.id;
                console.log(`ì¶”ì¶œí•œ ë‹¨ì–´ë¡œ vocabId ë§¤ì¹­ ì„±ê³µ: ${extractedWord} -> ${vocabId}`);
              } else {
                console.log(`ì¶”ì¶œí•œ ë‹¨ì–´ '${extractedWord}'ê°€ savedVocabsì— ì—†ìŒ`);
                vocabId = savedVocabs.length > 0 ? savedVocabs[0].id : 1;
                console.log(`vocabIdë¥¼ ê¸°ë³¸ê°’ ${vocabId}ë¡œ ì„¤ì •í•©ë‹ˆë‹¤.`);
              }
            } else {
              vocabId = savedVocabs.length > 0 ? savedVocabs[0].id : 1;
              console.log(`vocabIdë¥¼ ê¸°ë³¸ê°’ ${vocabId}ë¡œ ì„¤ì •í•©ë‹ˆë‹¤.`);
            }
          }
          
          // ë¬¸ì œ íƒ€ì… ë§¤í•‘ (ë°±ì—”ë“œ enumì— ë§ì¶¤)
          let mappedType = question.type;
          if (question.type === 'DICTATION') mappedType = 'DICTATION';
          else if (question.type === 'MULTIPLE') mappedType = 'MULTIPLE'; // MULTIPLE_CHOICEê°€ ì•„ë‹ˆë¼ MULTIPLE
          else if (question.type === 'OX') mappedType = 'OX';
          
          // stem í•„ë“œê°€ nullì´ ë˜ì§€ ì•Šë„ë¡ ê¸°ë³¸ê°’ ì„¤ì •
          console.log(`ë¬¸ì œ ì›ë³¸ ë°ì´í„°:`, question);
          console.log(`question.question:`, question.question);
          console.log(`question.stem:`, question.stem);
          
          const stemValue = question.question || question.stem || 'ë¬¸ì œ ë‚´ìš©ì´ ì—†ìŠµë‹ˆë‹¤';
          console.log(`ìµœì¢… stem ê°’:`, stemValue);
          
          const questionData = {
            quizId: createdQuiz.id,
            type: mappedType,
            stem: stemValue,
            correctAnswer: question.type === 'MULTIPLE' ? 
            (question.correctAnswer ? parseInt(question.correctAnswer) : 0) : 
            question.correctAnswer,
            explanation: question.explanation,
            points: question.points || 1,
            vocabId: vocabId,
            options: question.type === 'MULTIPLE' ? (question.options || []) : null
          };
          
          console.log('ë¬¸ì œ ìƒì„± ë°ì´í„°:', questionData);
          console.log('options í•„ë“œ í™•ì¸:', questionData.options);
          console.log('correctAnswer íƒ€ì… í™•ì¸:', typeof questionData.correctAnswer, questionData.correctAnswer);
        console.log('ì›ë³¸ correctAnswer:', question.correctAnswer);
        console.log('ë¬¸ì œ íƒ€ì…:', question.type);
          try {
            await questionService.createQuestion(questionData);
            console.log(`ë¬¸ì œ ìƒì„± ì™„ë£Œ: ${questionData.question}`);
          } catch (error) {
            console.error(`ë¬¸ì œ ìƒì„± ì‹¤íŒ¨: ${questionData.question}`, error);
            console.error('ë¬¸ì œ ë°ì´í„°:', JSON.stringify(questionData, null, 2));
            throw error;
          }
        }
      }
      
      console.log('ìë™ ìƒì„± í€´ì¦ˆ ì™„ì„±!');
      alert('ğŸ‰ AI ìë™ ìƒì„± í€´ì¦ˆê°€ ì„±ê³µì ìœ¼ë¡œ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤!');
      router.push('/dashboard/teacher');
      
    } catch (error) {
      console.error('ìë™ ìƒì„± í€´ì¦ˆ ìƒì„± ì˜¤ë¥˜:', error);
      alert('í€´ì¦ˆ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.');
    }
  };

  if (loading) {
    return <div>ë¡œë”© ì¤‘...</div>;
  }

  if (!user || user.type !== 'teacher') {
    return null;
  }

  // 1ë‹¨ê³„: ê¸°ë³¸ ì„¤ì •
  if (currentStep === 1) {
    return (
      <TestSetup
        initialConfig={initialConfig}
        onNext={async (config) => {
          if (config.isAutoGenerated) {
            // ìë™ ìƒì„± ëª¨ë“œ: ë°”ë¡œ í€´ì¦ˆ ìƒì„±
            console.log('ìë™ ìƒì„± ëª¨ë“œ: ë°”ë¡œ í€´ì¦ˆ ìƒì„± ì‹œì‘');
            await createQuizWithQuestions(config);
          } else {
            // ì¼ë°˜ ëª¨ë“œ: 2ë‹¨ê³„ë¡œ ì´ë™
            setTestConfig(config);
            setCurrentStep(2);
          }
        }}
        onBack={() => router.push('/dashboard/teacher')}
      />
    );
  }

  // 2ë‹¨ê³„: ë‹¨ì–´ ì„ íƒ
  if (currentStep === 2) {
    return (
      <VocabSelection
        testConfig={testConfig}
        onNext={async (configWithVocabs) => {
          try {
            console.log('ë‹¨ì–´ ì„ íƒ ì™„ë£Œ:', configWithVocabs);
            
            // í€´ì¦ˆ ìƒì„± ì—†ì´ ë‹¨ì–´ ì •ë³´ë§Œ ì „ë‹¬
            setTestConfig(configWithVocabs);
            setCurrentStep(3);
            
          } catch (error) {
            console.error('ë‹¨ì–´ ì„ íƒ ì²˜ë¦¬ ì˜¤ë¥˜:', error);
            alert('ë‹¨ì–´ ì„ íƒ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.');
          }
        }}
        onBack={() => setCurrentStep(1)}
        user={user}
      />
    );
  }

  // 3ë‹¨ê³„: ë¬¸ì œ ì‘ì„±
  if (currentStep === 3) {
    return (
      <TestCreation
        testConfig={testConfig}
        onSubmit={async (submittedConfig) => {
          console.log('TestCreationì—ì„œ ì œì¶œë¨:', submittedConfig);
          
          try {
            // ë°±ì—”ë“œ ì—°ê²° í™•ì¸
            try {
              const testResponse = await fetch('/api/test');
              if (!testResponse.ok) {
                throw new Error('ë°±ì—”ë“œ ì„œë²„ì— ì—°ê²°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
              }
              console.log('ë°±ì—”ë“œ ì—°ê²° í™•ì¸ë¨');
            } catch (connectionError) {
              console.error('ë°±ì—”ë“œ ì—°ê²° ì˜¤ë¥˜:', connectionError);
              alert('ë°±ì—”ë“œ ì„œë²„ì— ì—°ê²°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì„œë²„ê°€ ì‹¤í–‰ ì¤‘ì¸ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.');
              return;
            }
            
            const quizId = submittedConfig.id;
            
            if (!quizId) {
              throw new Error('í€´ì¦ˆ IDê°€ ì—†ìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.');
            }
            
            console.log('ê¸°ì¡´ í€´ì¦ˆì— ë¬¸ì œ ì¶”ê°€:', quizId);
            
            // TestCreationì—ì„œ ì´ë¯¸ ë¬¸ì œê°€ ìƒì„±ë˜ì—ˆìœ¼ë¯€ë¡œ ì¤‘ë³µ ìƒì„± ë°©ì§€
            console.log('TestCreationì—ì„œ ì´ë¯¸ ë¬¸ì œê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤. ì¤‘ë³µ ìƒì„±ì„ ê±´ë„ˆëœë‹ˆë‹¤.');
            
            alert('ğŸ‰ í€´ì¦ˆê°€ ì„±ê³µì ìœ¼ë¡œ ì™„ì„±ë˜ì—ˆìŠµë‹ˆë‹¤!');
            router.push('/dashboard/teacher');
            
          } catch (error) {
            console.error('í€´ì¦ˆ ì²˜ë¦¬ ì˜¤ë¥˜:', error);
            alert('âŒ í€´ì¦ˆ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
          }
        }}
        onBack={async () => {
          // ë‚˜ê°€ê¸° ì‹œë„ ì‹œ ê²½ê³ 
          const completedQuestions = testConfig?.questions?.filter(q => 
            q && q.question && q.question.trim() && q.vocabId && q.correctAnswer !== undefined && q.correctAnswer !== null && q.correctAnswer !== ''
          ) || [];
          
          if (completedQuestions.length < (testConfig?.questions?.length || 0)) {
            const incompleteCount = (testConfig?.questions?.length || 0) - completedQuestions.length;
            const confirmExit = confirm(
              `ì•„ì§ ${incompleteCount}ê°œì˜ ì§ˆë¬¸ì´ ëª¨ë‘ ì‘ì„±ë˜ì§€ ì•Šì•˜ì–´ìš”!\n\nê·¸ë˜ë„ ë‚˜ê°€ì‹œê² ì–´ìš”? ê·¸ëŸ¬ë©´ ì €ì¥ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤!`
            );
            
            if (confirmExit) {
              // í€´ì¦ˆ ì‚­ì œ
              if (testConfig?.id) {
                try {
                  console.log('ë¯¸ì™„ì„± í€´ì¦ˆ ì‚­ì œ ì‹œì‘:', testConfig.id);
                  await quizService.deleteQuiz(testConfig.id);
                  console.log('ë¯¸ì™„ì„± í€´ì¦ˆ ì‚­ì œ ì™„ë£Œ');
                } catch (error) {
                  console.error('í€´ì¦ˆ ì‚­ì œ ì˜¤ë¥˜:', error);
                }
              }
              setCurrentStep(2);
            }
          } else {
            setCurrentStep(2);
          }
        }}
        user={user}
      />
    );
  }

  return null;
} 